;definition d'un automate et verification de la syntaxe. retourne l'automate ou nil si il y'a une erreur et affiche l'erreur

  

(defun defautomate( &key vocabulaire etats initiaux finaux transitions)
  (labels ((pas-tous-diff (list-etats)
			  (if (null list-etats)
			      ()
			    (if (member (car list-etats) (cdr list-etats) :test 'equal)
				t
			      (pas-tous-diff (cdr list-etats)))))
	   (pas-dans-etats (list-etats)
			   (if (null list-etats)
			       ()
			     (if (member (car list-etats) etats :test 'equal)
				 (pas-dans-etats (cdr list-etats))
			       t)))
	   (trans-foireuses (list-trans)
			    (if (null list-trans)
				()
			      (if (bleme-dans-trans (car list-trans))
				  t
				(trans-foireuses (cdr list-trans)))))
	   (bleme-dans-trans (trans)
			     (if (member (car trans) etats :test 'equal)
					(bleme-dans-trans-aux (cdr trans))
				      t))
	   (bleme-dans-trans-aux (trans-list)
				 (cond ((null trans-list) ())
				       ((atom (car trans-list)) t)
				       ((or (member (caar trans-list) vocabulaire) (null (caar trans-list)) :test 'equal)
					(if (pas-dans-etats (cdar trans-list))
					    t
					  (bleme-dans-trans-aux (cdr trans-list))))
				       (t t))))
    (cond ((atom vocabulaire) (print "Erreur de voca")())
	  ((atom etats) (print "Erreur etats")())
	  ((atom initiaux) (print "Erreur initiaux")())
	  ((atom finaux) (print "Erreur finaux")())
	  ((atom transitions) (print "Erreur transitions")())
	  ((pas-tous-diff vocabulaire) (print "Erreur char en double")())
	  ((pas-tous-diff etats) (print "Erreur etat en double")())
	  ((pas-tous-diff initiaux) (print "Erreur initil en double")())
	  ((pas-tous-diff finaux) (print "Erreur final en double")())
	  ((pas-tous-diff transitions) (print "Erreur transition en double")())
	  ((pas-dans-etats initiaux) (print "initial inconnu")())
	  ((pas-dans-etats finaux) (print "final inconnu")())
	  ((trans-foireuses transitions) (print "bleme de transition")())
	  (t (list vocabulaire etats initiaux finaux transitions)))))


(defun defautomatesure( &key vocabulaire etats initiaux finaux transitions)
  (list vocabulaire etats initiaux finaux transitions))

;fonctions d'accès au parties d'un automate: vocabulaire, etats, initiaux, finaux, transitions

(defun vocabulaire (automate)
  (car automate)
  )

(defun etats (automate)
  (cadr automate)
  )

(defun initiaux (automate)
  (caddr automate)
  )

(defun finaux (automate)
  (cadddr automate)
  )

(defun transitions (automate)
  (car (cddddr automate))
  )

(defun initial (automate)
  (car (initiaux automate))
  )

(defun final (automate)
  (car (finaux automate))
  )

;test si un mot est reconnue par l'automate dans le cas deterministe

(defun eval-automate-det (mot automate)
  (labels ((aux(m e)
	       (if (null m)
		   (member e (finaux automate))
		 (if (null (trans (car m) e))
		     nil
		   (aux (cdr m) (car (trans (car m) e))))))
	   (trans(c e)
		 (cdr (assoc c (cdr (assoc e (transitions automate)))))))
    (aux mot (initial automate)))
  )

;test si un mot est reconnue par l'automate dans le cas général

(defun eval-automate(mot automate)
  (labels ((aux(m le)
	       (if (null le)
		   nil
		 (if (null m)
		     (or (member (car le) (finaux automate))
			 (aux m (cdr le))
			 (aux m (trans nil (car le))))
		     (or (aux (cdr m) (trans (car m) (car le)))
			 (aux m (cdr le))
			 (aux m (trans nil (car le)))))))


	   (trans(c e)
		 (cdr (assoc c (cdr (assoc e (transitions automate)))))))
    (aux mot (initiaux automate))
  ))


;genere un automate a partir d'une expression reguliere ecrite en notation prefixée

(defun make-automate(er)
  ((lambda(x)
    (defun compteur() x)
    (defun incr-compteur(&optional (n 1))
      (setf x (+ x n))))
   0)
  (labels ((make-aux(er)
		    (cond ((atom er) (base er))
			  ((= (length er) 3) (cond
					      ((equal (car er) '+) (union (make-aux (cadr er))
						       (make-aux (caddr er))))
					      ((equal (car er) '°) (concat (make-aux (cadr er))
							(make-aux (caddr er))))
					      (t (error "erreur de syntaxe"))))
			  ((and (= (length er) 2)
				(equal (car er) '*)) (fermeture (make-aux (cadr er))))
			  (t (error "erreur de syntaxe"))))
	   (union(a1 a2)
		 (defautomatesure :vocabulaire (concat-diff (vocabulaire a1) (vocabulaire a2))
		   :initiaux (list (incr-compteur))
		   :finaux (list (incr-compteur))
		   :etats (append (list (- (compteur) 1)) (concat-diff (etats a1) (etats a2)) (list (compteur)))
		   :transitions (append (list (list (- (compteur) 1)
						    (list nil (initial a1) (initial a2)))
					      (list (final a1)
						    (list nil (compteur)))
					      (list (final a2)
						    (list nil (compteur))))
					(transitions a1)
					(transitions a2))))
	   (concat(a1 a2)
		  (defautomate :vocabulaire (concat-diff (vocabulaire a1) (vocabulaire a2))
		    :etats (concat-diff (etats a1) (etats a2))
		    :initiaux (initiaux a1)
		    :finaux (finaux a2)
		    :transitions (cons (list (final a1)
					     (list nil (initial a2)))
				       (append (transitions a1)
					       (transitions a2)))))
	   (fermeture(a)
		     (defautomate :vocabulaire (vocabulaire a)
		       :initiaux (list (incr-compteur))
		       :finaux (list (incr-compteur))
		       :etats (concat-diff (concat-diff (list (- (compteur) 1)) (etats a)) (list (compteur)))
		       :transitions (append (list
					     (list (- (compteur) 1)
						   (list nil (initial a) (compteur)))
					     (list (final a)
						   (list nil (compteur)
							 (initial a))))
					    (transitions a))))
	   (base(c)
		(defautomate :vocabulaire (list c)
		  :initiaux (list (incr-compteur))
		  :finaux (list (incr-compteur))
		  :etats (list (- (compteur) 1) (compteur))
		  :transitions (list (list (- (compteur) 1) (list c (compteur)))))))
    (make-aux er))
  )

;compile un automate deterministe

(defmacro compile-auto-det(&key initial finaux transitions)
  (let ((etats-fn (labels
		      ((associe(l)
			      (if (null l)
				  nil
				(cons (cons (caar l) (gensym)) (associe (cdr l))))))
		    (associe transitions))))
    (labels
	((etat(e)
	      (or (cdr (assoc e etats-fn))
		  (error "etat inconnu: ~W" e)))

	 (compile-trans(tr)
		       `(,(car tr) (,(etat (cadr tr)) (cdr m))))

	 (map-compile-trans(ltr)
			   (if (null ltr)
			       nil
			     (cons (compile-trans (car ltr))
				   (map-compile-trans (cdr ltr)))))

	 (compile-etat(e ltr f)
		      `(,(etat e) (m)
			(if (null m)
			    ,(not (not f))
			  (case (car m)
			    ;,@(mapcar #'compile-trans ltr)))))
			    ,@(map-compile-trans ltr)))))

	 (compile-etat-2(trans)
	     (if (null trans)
		 nil
	       (compile-etat (car trans) (cdr trans) (member (car trans) finaux))))

	 (map-compile-etat-2(transitions)
			    (if (null transitions)
				nil
			      
			      (cons (compile-etat-2 (car transitions))
						    (map-compile-etat-2 (cdr transitions))))))
      
      `(defun comp-auto(mot)
	 (labels ,(map-compile-etat-2 transitions) ;,(mapcar #'compile-etat-2 transitions)
	   (,(etat initial) mot)))))
  )

;compile un automate dans le cas general

(defmacro compile-auto(&key initial finaux transitions)
  (let ((etats-fn (labels
		      ((associe(l)
			       (if (null l)
				   nil
				 (cons (cons (caar l) (gensym)) (associe (cdr l))))))
		    (associe transitions))))
    (labels
	((etat(e)
	      (let ((c (assoc e etats-fn)))
		(if c
		    (cdr c)
		  (error "etat inconnu: ~W" e))))

	 ; tr		= (a 1)
	 ; etat(1)	= f1
	 ; -> (f1 (cdr m))
	 (compile-trans(tr)
		       `(,(car tr) (,(etat (cadr tr)) (cdr m))))

	 (map-compile-trans(ltr)
			   (if (null ltr)
			       nil
			     (cons (compile-trans (car ltr))
				   (map-compile-trans (cdr ltr)))))

	 ; e		= 1
	 ; etat(1)	= f1
	 ; ltr		= ((a 2) (b 3))
	 ; f		= t
	 ; -> (f1 (m)
	 ;	(if (null m)
	 ;		(not (not g))
	 ;		(case (car m)
	 ;			(a (f2 (cdr m)))
	 ;			(b (f3 (cdr m))))))
	 (compile-etat(e ltr f)
		      `(,(etat e) (m)
			(if (null m)
			    ,(not (not f))
			  (case (car m)
			    ;,@(mapcar #'compile-trans ltr)))))
			    ,@(map-compile-trans ltr)))))

	 ; trans	= 
	 (compile-etat-2(trans)
	     (if (null trans)
		 nil
	       (compile-etat (car trans) (cdr trans) (member (car trans) finaux))))

	 (map-compile-etat-2(transitions)
			    (if (null transitions)
				nil

			      (cons (compile-etat-2 (car transitions))
						    (map-compile-etat-2 (cdr transitions))))))
      
      `(defun comp-auto(mot)
	 (labels ,(map-compile-etat-2 transitions) ;(mapcar #'compile-etat-2 transitions)
	   (,(etat initial) mot)))))
  )

;utilitaires

(defun concat-diff (l1 l2)
  (if (null l2)
     l1
    (if (member (car l2) l1 :test 'equal)
	(concat-diff l1 (cdr l2))
      (concat-diff (append l1 (list (car l2))) (cdr l2)))))

(defun diff (l1 l2)
  (if (null l1)
      l1
    (if (member (car l1) l2 :test 'equal)
	(diff (cdr l1) l2)
      (cons (car l1) (diff (cdr l1) l2)))))



(defun renommer-etats-auto-pour-determiniser (auto)
  (let ((etats (etats auto)))
    (labels ((renommer-etats (list-etats etats)
			     (if (null list-etats)
				 ()
			       (cons (- (length etats) 
					(length (member (car list-etats) etats :test 'equal)))
				     (renommer-etats (cdr list-etats) etats))))
	     (renommer-etats-dans-trans (list-trans etats)
					  (if (null list-trans)
					      ()
					    (cons (renommer-trans (car list-trans))
						  (renommer-etats-dans-trans (cdr list-trans) etats))))
	     (renommer-trans (trans)
								   (cons (- (length etats)
									    (length (member (car trans) etats :test 'equal)))
									 (renommer-chars-etats (cdr trans))))
	     (renommer-chars-etats (list-chars-etats)
												(if (null list-chars-etats)
												    ()
												  (cons (list (caar list-chars-etats)
													      (- (length etats) 
														 (length (member 
															  (cdar list-chars-etats) 
															  etats :test 'equal))))
													(renommer-chars-etats 
													 (cdr list-chars-etats)))))
)
      (defautomatesure :vocabulaire (vocabulaire auto)
	:etats (renommer-etats etats etats)
	:initiaux (renommer-etats (initiaux auto) etats)
	:finaux (renommer-etats (finaux auto) etats)
	:transitions (renommer-etats-dans-trans (transitions auto) etats)))))

(defun renommer-etats-auto (auto)
  (let ((etats (etats auto)))
    (labels ((renommer-etats (list-etats etats)
			     (if (null list-etats)
				 ()
			       (cons (- (length etats) 
					(length (member (car list-etats) etats :test 'equal)))
				     (renommer-etats (cdr list-etats) etats))))
	     (renommer-etats-dans-trans (list-trans etats)
					  (if (null list-trans)
					      ()
					    (cons (renommer-trans (car list-trans))
						  (renommer-etats-dans-trans (cdr list-trans) etats))))
	     (renommer-chars-etats (list-chars-etats)
				   (if (null list-chars-etats)
				       ()
				     (cons (list (caar list-chars-etats)
						 (- (length etats) 
						    (length (member 
							     (cadar list-chars-etats) 
							     etats :test 'equal))))
					   (renommer-chars-etats 
					    (cdr list-chars-etats)))))
	     (renommer-trans (trans)
			     
			     (cons (- (length etats)
				      (length (member (car trans) etats :test 'equal)))
				   (renommer-chars-etats (cdr trans)))))
      (defautomatesure :vocabulaire (vocabulaire auto)
	:etats (renommer-etats etats etats)
	:initiaux (renommer-etats (initiaux auto) etats)
	:finaux (renommer-etats (finaux auto) etats)
	:transitions (renommer-etats-dans-trans (transitions auto) etats)))))


;determinisation d'un automate ne contenant pas d'epsilon transitions

(defun determinise-auto (auto)
  (if (null auto) (print "erreur d'automate avant de determiniser")
    (progn
      (let ((a (epsilon-elimine-auto auto)))
	(print a)
	(labels ((new-auto (list-etats etats-courants transi)
			   (print transi)
			 (if (null etats-courants)
			     (renommer-etats-auto-pour-determiniser
			      (defautomatesure :vocabulaire (vocabulaire a)
				:etats list-etats
				:initiaux (list (initiaux a))
				:finaux (trouver-finaux list-etats)
				:transitions transi))
			   (let* ((var (etat-new-trans (car etats-courants)))
				  (nouveaux-etats-new (diff (etats-dans-trans-new var) list-etats)))
			     (if (null var)
				 (new-auto (append list-etats nouveaux-etats-new)
					   (cdr (append etats-courants nouveaux-etats-new))
					   transi)
			       (new-auto (append list-etats nouveaux-etats-new)
					 (cdr (append etats-courants nouveaux-etats-new))
					 (append transi (list var)))))))
			 
	       (trouver-finaux (list-etats-new)
			       (labels ((etat-final (etat-new)
						    (if (null etat-new)
							()
						      (if (member (car etat-new) (finaux a))
							  etat-new
							(etat-final (cdr etat-new))))))
				 (if (null list-etats-new)
				     ()
				   (if (etat-final (car list-etats-new))
				       (cons (car list-etats-new) (trouver-finaux (cdr list-etats-new)))
				   (trouver-finaux (cdr list-etats-new))))))
	       
	       (etat-new-trans (etat-new)
			       (labels ((etat-new-trans-aux (etat-new)
							    (if (null etat-new)
								()
							      (concat-diff (etat-trans (car etat-new))
									   (etat-new-trans-aux (cdr etat-new)))))
					(etat-trans (etat)
						    (cdr (assoc etat (transitions a)))))
				 (let ((var (etat-new-trans-aux etat-new)))
				   (if (null var)
				       ()
				     (cons etat-new var)))))
	       
	       (etats-dans-trans-new (trans-new)
				     (labels ((aux (chars-etats)
						   (if (null chars-etats)
						       () 
						     (cons (cdar chars-etats)
							   (aux (cdr chars-etats))))))
				       (aux (cdr trans-new)))))
	    (new-auto  (list (initiaux a))
		      (list (initiaux a))
		      ()))))))


;complete un automate (utilisé par la fonction de minimisation)

(defun complete-auto (auto)
  (let* ((etats (etats auto))
	 (etat-puis (labels ((nouvel-etat (etat-new)
					  (if (member etat-new etats)
					      (nouvel-etat (+ 1 etat-new))
					    etat-new)))
		      (nouvel-etat (length etats)))))
    (labels ((complete-transitions (etats)
				   (if (null etats)
				       ()
				     (cons (cons (car etats) (complete-trans-etat (assoc (car etats) (transitions auto)) (vocabulaire auto)))
					   (complete-transitions (cdr etats)))))
	     (complete-trans-etat (trans-etat voca)
				  (if (null voca)
				      ()
				    (if (assoc (car voca) (cdr trans-etat))
					(cons (assoc (car voca) (cdr trans-etat))
					      (complete-trans-etat trans-etat (cdr voca)))
				      (cons (list (car voca) etat-puis)
					    (complete-trans-etat trans-etat (cdr voca)))))))
      
      (defautomatesure :vocabulaire (vocabulaire auto)
	:etats (append etats (list etat-puis))
	:initiaux (initiaux auto)
	:finaux (finaux auto)
	:transitions (complete-transitions (append etats (list etat-puis)))))))
				  

	
;minimisation d'un automate deterministe
						   
(defun minimise-auto (auto)
  (if (null auto) (print "erreur avant de minimiser")
    (progn
  (let* ((auto (determinise-auto auto))
	 (auto-complet (complete-auto auto))
	 (etats (etats auto-complet))
	 (voca (vocabulaire auto))
	 (trans (transitions auto-complet))
	 (initiaux (initiaux auto-complet))
	 (finaux (finaux auto-complet)))
    (labels ((new-auto (partition)
		       (let ((part (partitionne partition partition)))
			 (if (equal partition
				    part)
			     (renommer-etats-auto (suppr-etats-puits-et-non-atteignables (reconstituer-auto partition)))
			   (new-auto part))))
	     (partitionne (parti partition)
			  (if (null parti)
			      ()
			    (append (partitionne-classe (car parti) voca partition)
				    (partitionne (cdr parti) partition))))
	     (partitionne-classe (classe voc partition)
				 (if (null voc)
				     (list classe)
				   (if (equal (list classe)
					      (partitionne-classe-char classe (car voc) partition))
				       (partitionne-classe classe (cdr voc) partition)
				     (partitionne-classe-char classe (car voc) partition))))
	     (partitionne-classe-char (classe char parti)
				      (if (null parti)
					  ()
					(if (partitionne-classe-char-dest classe (car parti) char)
					    (cons (partitionne-classe-char-dest classe (car parti) char)
						  (partitionne-classe-char classe char (cdr parti)))
						(partitionne-classe-char classe char (cdr parti)))))
	     (partitionne-classe-char-dest (classe-orig classe-dest char)
					   (if (null classe-orig)
					       ()
					     (if (member (etat-suivant (car classe-orig) char)
							 classe-dest)
						 (cons (car classe-orig)
						       (partitionne-classe-char-dest (cdr classe-orig) classe-dest char))
					       (partitionne-classe-char-dest (cdr classe-orig) classe-dest char))))
	     (etat-suivant (etat char)
			   (cadr (assoc char (assoc etat trans))))
	     (reconstituer-auto (partition)
				(labels ((trouver-initial (parti)
							  (if (contient-initial (car parti))
							      (car parti)
							    (trouver-initial (cdr parti))))
					 (contient-initial (classe)
							   (if (null classe)
							       ()
							     (if (member (car classe) initiaux)
								 (car classe)
							       (contient-initial (cdr classe)))))
					 (trouver-finaux (parti)
							 (if (null parti)
							     ()
							   (if (contient-final (car parti))
							       (cons (car parti)
								     (trouver-finaux (cdr parti)))
							     (trouver-finaux (cdr parti)))))
					 (contient-final (classe)
							 (if (null classe)
							     ()
							   (if (member (car classe) finaux)
							       (car classe)
							     (contient-final (cdr classe)))))
					 (nouvelles-trans (parti partition)
							  (if (null parti)
							      ()
							    (cons (cons (car parti)
									(transitions-depuis (car parti) partition))
								  (nouvelles-trans (cdr parti) partition))))
					 (transitions-depuis (etat-new partition)
							     (if (null etat-new)
								 ()
							       (concat-diff (transitions-depuis-etat-ancien (cdr (assoc (car etat-new)
															trans))
													    partition)
									    (transitions-depuis (cdr etat-new) partition))))
					 (transitions-depuis-etat-ancien (list-dest-ancien partition)
									 (if (null list-dest-ancien)
									     ()
									   (cons (cons (caar list-dest-ancien)
										       (list (nouvel-etat (cadar list-dest-ancien) partition)))
										 (transitions-depuis-etat-ancien (cdr list-dest-ancien)
														 partition))))
					 (nouvel-etat (etat-ancien parti)
						      (if (member etat-ancien (car parti))
							  (car parti)
							(nouvel-etat etat-ancien (cdr parti)))))
				  (defautomatesure :vocabulaire (vocabulaire auto)
				    :etats partition
				    :initiaux (list (trouver-initial partition))
				    :finaux (trouver-finaux partition)
				    :transitions (nouvelles-trans partition partition))))
	     (suppr-etats-puits-et-non-atteignables (auto)
						   (let ((etats (etats auto))
							 (transitions (transitions auto))
							 (initiaux (initiaux auto))
							 (finaux (finaux auto)))
						     (labels ((new-etats (list-etats)
									  (if (null list-etats)
									      ()
									    (if (etat-non-atteignable (car list-etats) transitions)
										(new-etats (cdr list-etats ))
									      (if (etat-puis (car list-etats) transitions)
										  (new-etats (cdr list-etats))
										(cons (car list-etats)
										      (new-etats (cdr list-etats)))))))
							      (etat-non-atteignable (etat trans)
										    (if (member etat initiaux)
											()
										      (if (null trans)
											  etat
											(if (equal etat (caar trans))
											    (etat-non-atteignable etat (cdr trans))
											  (if (atteignable-par-trans etat  (cdar trans))
											      ()
											    (etat-non-atteignable etat (cdr trans)))))))
							      (atteignable-par-trans (etat list-dest)
										     (if (null list-dest)
											 ()
										       (if (equal (cadar list-dest) etat)
											   etat
											 (atteignable-par-trans etat (cdr list-dest)))))
							      (etat-puis (etat trans)
									 (if (member etat finaux)
									     ()
									   (if (assoc etat trans)
									       (trans-vers-lui-meme etat (cdr (assoc etat trans)))
									     etat)))
							      (trans-vers-lui-meme (etat list-dest)
										   (if (null list-dest)
										       etat
										     (if (equal (cadar list-dest) etat)
											 (trans-vers-lui-meme etat (cdr list-dest))
										       ())))
							      (suppr-etats-suppr-dans-trans (etats-suppr trans)
											    (if (null trans)
												()
											      (if (member (caar trans) etats-suppr)
												  (suppr-etats-suppr-dans-trans etats-suppr (cdr trans))
												(if (suppr-etats-suppr-dans-list-dest etats-suppr (cdar trans))
												    (cons (cons (caar trans)
														(suppr-etats-suppr-dans-list-dest etats-suppr (cdar trans)))
													  (suppr-etats-suppr-dans-trans etats-suppr (cdr trans)))
												  (suppr-etats-suppr-dans-trans etats-suppr (cdr trans))))))
							      (suppr-etats-suppr-dans-list-dest (etats-suppr list-dest)
												(if (null list-dest)
												    ()
												  (if (member (cadar list-dest) etats-suppr)
												      (suppr-etats-suppr-dans-list-dest etats-suppr (cdr list-dest))
												    (cons (car list-dest)
													  (suppr-etats-suppr-dans-list-dest etats-suppr (cdr list-dest)))))))
						       
						       (defautomatesure :vocabulaire (vocabulaire auto)
							 :etats (new-etats etats)
							 :initiaux (initiaux auto)
							 :finaux (finaux auto)
							 :transitions (suppr-etats-suppr-dans-trans (diff etats (new-etats etats))
												    transitions)))))

)
									    

      (new-auto (list (finaux auto-complet) (diff etats (finaux auto-complet)))))))))



;elimination des epsilon transitions. à utiliser avant de determiniser, en particulier pour les automates generé par make-automate

(defun epsilon-elimine-auto (auto)
  (let ((vocabulaire (vocabulaire auto))
	(etats (etats auto))
	(initiaux (initiaux auto))
	(finaux (finaux auto))
	(transitions (transitions auto)))
    (labels ((augmente-trans (auto)
			     (labels ((augmente-trans-si-diff (trans)
							      (if (equal (augmente-trans-aux trans trans) trans)
								  trans
								(augmente-trans-si-diff (augmente-trans-aux trans trans))))
				      (augmente-trans-aux (list-trans trans)
							  (if (null list-trans )
							      ()
							    (cons (cons (caar list-trans)
									(augmente-une-trans (cdar list-trans) trans))
								  (augmente-trans-aux (cdr list-trans) trans))))
				      (augmente-une-trans (transi-list trans)
							  (if (null transi-list)
							      ()
							    (if (null (caar transi-list))
								(cons (car transi-list)
								      (concat-diff (cdr transi-list)
										   (augmente-epsilon-list (cdar transi-list) trans)))
							      (cons (car transi-list)
								    (augmente-une-trans (cdr transi-list) trans)))))
				      (augmente-epsilon-list (etats-arr trans)
							     (if (null etats-arr)
								 ()
							       (concat-diff (augmente-epsilon (assoc (car etats-arr) trans))
									    (augmente-epsilon-list (cdr etats-arr) trans))))
				      (augmente-epsilon (trans-list-corresp)
							(cond ((null trans-list-corresp) ())
							      ((atom (car trans-list-corresp))
							       (augmente-epsilon (cdr trans-list-corresp)))
							      ((null (caar trans-list-corresp))
							       (augmente-epsilon (cdr trans-list-corresp)))
							      ((atom (caar trans-list-corresp))
							       (cons (car trans-list-corresp)
								     (augmente-epsilon (cdr trans-list-corresp)))))))

			       (defautomatesure :vocabulaire vocabulaire
				 :etats etats
				 :initiaux initiaux
				 :finaux finaux
				 :transitions (augmente-trans-si-diff transitions))))

	     (propage-finaux (auto)
			     (labels ((propage-finaux-si-diff (finaux etats)
							      (if (equal (propage-finaux-aux finaux etats)
									 finaux)
								  finaux
								(propage-finaux-si-diff (propage-finaux-aux finaux etats) etats)))
				      (propage-finaux-aux (finaux list-etats)
							  (cond ((null list-etats) ())
								((member (car list-etats) finaux)
								 (cons (car list-etats)
								       (propage-finaux-aux finaux (cdr list-etats))))
								((epsi-trans-vers-final finaux (car list-etats) (assoc (car list-etats) transitions))
								 (cons (car list-etats)
								       (propage-finaux-aux finaux (cdr list-etats))))
								(t (propage-finaux-aux finaux (cdr list-etats)))))
				      (epsi-trans-vers-final (finaux etat etat-trans)
							     (cond ((null etat-trans) ())
								   ((atom (car etat-trans))
								    (epsi-trans-vers-final finaux etat (cdr etat-trans)))
								   ((null (caar etat-trans))
								    (if (contient-final finaux (cdar etat-trans))
									etat
								      ()))
								   ((atom (caar etat-trans))
								    (epsi-trans-vers-final finaux etat (cdr etat-trans)))))
				      (contient-final (finaux list-epsi-arr)
						      (if (null list-epsi-arr)
							  ()
							(if (member (car list-epsi-arr) finaux)
							    (car list-epsi-arr)
							  (contient-final finaux (cdr list-epsi-arr))))))

			       (defautomatesure :vocabulaire vocabulaire
				 :etats etats
				 :initiaux initiaux
				 :finaux (propage-finaux-si-diff finaux etats)
				 :transitions (transitions auto))))

	     (suppr-epsilon-trans (auto)
				  (labels ((suppr-epsi-trans-aux (list-trans)
								 (if (null list-trans)
								     ()
								   (if (suppr-epsi-trans-dans-trans (cdar list-trans))
								       (cons (cons (caar list-trans)
										   (suppr-epsi-trans-dans-trans (cdar list-trans)))
									     (suppr-epsi-trans-aux (cdr list-trans)))
								     (suppr-epsi-trans-aux (cdr list-trans)))))
					   (suppr-epsi-trans-dans-trans (list-trans-arr)
									(if (null list-trans-arr)
									    ()
									  (if (null (caar list-trans-arr))
									      (suppr-epsi-trans-dans-trans (cdr list-trans-arr))
									    (cons (car list-trans-arr)
										  (suppr-epsi-trans-dans-trans (cdr list-trans-arr)))))))
				    (defautomatesure :vocabulaire vocabulaire
				      :etats etats
				      :initiaux initiaux
				      :finaux (finaux auto)
				      :transitions (suppr-epsi-trans-aux (transitions auto)))))

	     (elimine-etats-inaccessibles (auto)
					  (labels ((elimine-aux (list-etats)
								(if (null list-etats)
								    ()
								  (if (etat-inaccessible (car list-etats) (transitions auto))
								      (elimine-aux (cdr list-etats))
								    (cons (car list-etats)
									  (elimine-aux (cdr list-etats))))))
						   (etat-inaccessible (etat list-trans)
								      (cond ((member etat initiaux)
									     ())
									    ((null list-trans)
									     t)
									    ((equal etat (caar list-trans))
									     (etat-inaccessible etat (cdr list-trans)))
									    ((accessible-par-trans etat (cdar list-trans))
									     ())
									    (t (etat-inaccessible etat (cdr list-trans)))))
						   (accessible-par-trans (etat list-dest)
									 (if (null list-dest)
									     ()
									   (if (member etat (cdar list-dest))
									       etat
									     (accessible-par-trans etat (cdr list-dest)))))
						   (suppr-etats-suppr-dans-trans (etats-suppr list-trans)
										 (cond ((null list-trans)
											())
										       ((member (caar list-trans) etats-suppr)
											(suppr-etats-suppr-dans-trans etats-suppr (cdr list-trans)))
										       ((suppr-etats-suppr-dans-list-dest etats-suppr (cdar list-trans))
											 (cons (cons (caar list-trans)
												     (suppr-etats-suppr-dans-list-dest etats-suppr
																(cdar list-trans)))
											       (suppr-etats-suppr-dans-trans etats-suppr (cdr list-trans))))
										       (t (suppr-etats-suppr-dans-trans etats-suppr
															(cdr list-trans)))))
						   (suppr-etats-suppr-dans-list-dest (etats-suppr list-dest)
										     (if (null list-dest)
											 ()
										       (if (suppr-etats-suppr-detail etats-suppr
														     (cdar list-dest))
											   (cons (cons (caar list-dest)
												       (suppr-etats-suppr-detail etats-suppr
																 (cdar list-dest)))
												 (suppr-etats-suppr-dans-list-dest etats-suppr
																   (cdr list-dest)))
											 (suppr-etats-suppr-dans-list-dest etats-suppr
															   (cdr list-dest)))))
						   (suppr-etats-suppr-detail (etats-suppr trans-arr)
									     (if (null trans-arr)
										 ()
									       (if (member (car trans-arr) etats-suppr)
										   (suppr-etats-suppr-detail etats-suppr (cdr trans-arr))
										 (cons (car trans-arr)
										       (suppr-etats-suppr-detail etats-suppr (cdr trans-arr)))))))

					    (defautomatesure :vocabulaire vocabulaire
					      :etats (elimine-aux (etats auto))
					      :initiaux initiaux
					      :finaux (elimine-aux (finaux auto))
					      :transitions (suppr-etats-suppr-dans-trans (diff (etats auto) (elimine-aux (etats auto))) (transitions auto)))))




)

      (elimine-etats-inaccessibles (suppr-epsilon-trans (propage-finaux (augmente-trans auto)))))))


	 