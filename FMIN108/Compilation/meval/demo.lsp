;******************** DEMO METAEVAL ********************

(mdefun fibo (n)
	(if (< n 2)
	     n
	   (+ (fibo (- n 2)) (fibo (- n 1)))))

(mdefun fiboterm (n)
	(labels ((aux (n &optional (n2 1) (n1 0) (i 2))
		      (if (<= i n)
			  (aux n (+ n2 n1) n2 (+ i 1))
			n2)))
	  (if (< n 2) n (aux n))))


(mdefun factterm(n)
	(labels ((f(n m)
		   (if (= n 0)
		       m
		     (f (- n 1) (* n m)))))
	  (f n 1)))

(mdefun fact(n)
	(if (= n 0)
	    1
	  (* n (fact (- n 1)))))


(let (expr c expr2 nod n (A1 (defautomate
			       :vocabulaire '(a b c)
			       :etats '(0 1 2 3 4 5 6)
			       :initiaux '(0 4)
			       :finaux '(3 6)
			       :transitions '((0 (a 1))
					      (1 (b 2 4))
					      (2 (c 2) (a 3 5))
					      (4 (c 2))
					      (5 (b 6))
					      (6 (a 2 3))))))
  (defun pgdwn () (format *standard-output* "~%~%~%~%~%~%~%~%~%~%~%~%~%~%~%~%~%~%~%~%"))
  (defun meval+ ()
    (setf n (+ 1 n)))
  (defun meval- ()
    (if (> n 0)
	(setf n (- n 1))))
  (defun state ()
    (format *standard-output* "----------------------------------------------------------------------------------------------~%")
    (format *standard-output* "Dernière expression traitée: ~W~%" expr2)
    (format *standard-output* "Expression courante: ~W~%" expr)
    (format *standard-output* "Niveau de métaévaluation: ~W~%" n)
    (format *standard-output* "Débuggage de la machine virtuelle: ~W~%" (if (debogage) "activé" "désactivé"))
    (format *standard-output* "----------------------------------------------------------------------------------------------~%"))
  (defun stata ()
    (format *standard-output* "-----------------------------------------------------------------------------------------~%")
    (format *standard-output* "Dernière expression traitée: ~W~%" expr2)
    (format *standard-output* "Expression courante: ~W~%" expr)
    (format *standard-output* "Automate A1: ~W~%" A1)
    (format *standard-output* "Niveau de métaévaluations: ~W~%" n)
    (format *standard-output* "Débuggage de la machine virtuelle: ~W~%" (if (debogage) "activé" "désactivé"))
    (format *standard-output* "-----------------------------------------------------------------------------------------~%"))

  (pgdwn)
  (format *standard-output* "~%**********************************************************************************************~%")
  (format *standard-output* "---------- DEMO METAEVALUATEUR + GENERATEUR DE CODE + MACHINE VIRTUELLE + AUTOMATES ----------~%")
  (format *standard-output* "----------------- le métaévaluateur et son environnement par Xavier ANDREANI -----------------~%")
  (format *standard-output* "------------------------- le générateur de code par Gauthier HADERER -------------------------~%")
  (format *standard-output* "---------------------------- la machine virtuelle par Eric BOULAT ----------------------------~%")
  (format *standard-output* "------------------------------- les automates par Yann SARAZIN -------------------------------")
  (labels ((aux (n expr)
		(labels ((aux2 (n expr)
			       (if (<= n 0) (list 'quote expr)
				 (list 'quote (list 'meval (aux2 (- n 1) expr))))))
		  (eval (aux2 n expr)))))
    (loop while (and (not (equal c '#\Q)) (not (equal c '#\q))) do
      (if (not nod)
	  (progn (format *standard-output* "~%**********************************************************************************************~%")
		 (format *standard-output* "1) Métaévaluer une expression~%")
		 (format *standard-output* "2) Compiler des fonctions, macros ou expressions~%")
		 (format *standard-output* "3) Compiler et évaluer une expression dans la machine virtuelle~%")
		 (format *standard-output* "4) Traiter des automates~%")
		 (format *standard-output* "Q> Quitter~%")
		 (state)
		 (format *standard-output* "Faites votre choix: "))
	(setf nod nil))
      (clear-input)
      (setf c (read-char))
      (setf expr2 ())
      (cond ((equal c '#\1)
	      (pgdwn)
	      (let (c)
		(setf n 1)
		(debogage-desactive)
		(loop while (and (not (equal c '#\r)) (not (equal c '#\R))) do
		  (if (not nod)
		      (progn (format *standard-output* "~%**********************************************************************************************~%")
			     (format *standard-output* "1) 1> Fonctions et capture de variables~%")
			     (format *standard-output* "   2> Fonctions et environnements~%")
			     (format *standard-output* "   3> Closures~%")
			     (format *standard-output* "   4> Labels~%")
			     (format *standard-output* "   5> Mots clés et arguments optionnels~%")
			     (format *standard-output* "   6> Fibonacci récursion enveloppée~%")
			     (format *standard-output* "   7> Fibonacci récursion terminale~%")
			     (format *standard-output* "   8> Macros~%")
			     (format *standard-output* "   9> Factorielle récursion enveloppée~%")
			     (format *standard-output* "   0> Factorielle récursion terminale~%")			     
			     (format *standard-output* "   +) Ajouter un niveau de métaévaluation~%")
			     (format *standard-output* "   -) Retirer un niveau de métaévaluation~%")
			     (format *standard-output* "   U> Evaluer une expression~%")
			     (format *standard-output* "   D) Activer / désactiver le débuggage de la machine virtuelle~%")
			     (format *standard-output* "   R) Retour~%")
			     (state)
			     (format *standard-output* "Faites votre choix: "))
		    (setf nod nil))
		  (clear-input)
		  (setf c (read-char))
		  (setf expr2 ())
		  (cond ((equal c '#\+) (meval+) (pgdwn))
			((equal c '#\-) (meval-) (pgdwn))
			((or (equal c '#\d) (equal c '#\D)) (debogage-inverse) (pgdwn))
			((or (equal c '#\u) (equal c '#\U)) (setf expr2 (read)))
			((equal c '#\1) (setf expr2 '(progn (let ((x 0)) (defun x++ () (setf x (+ 1 x))) (defun x () x))
							    (x++)
							    (x))))
			((equal c '#\2) (setf expr2 '(progn (setf a 5)
							    (defun bar (x) (* x a))
							    (let ((a 7)) (bar 6)))))
			((equal c '#\3) (setf expr2 '(apply (let ((a 5)) #'(lambda (b) (* a b))) '(9))))
			((equal c '#\4) (setf expr2 '(progn (defun foo (lst) (labels ((fact (n) (if (< n 1) 1 (* n (fact (- n 1)))))) (if lst (cons (fact (car lst)) (foo (cdr lst))) nil)))
							    (foo '(1 2 3 4 5)))))
			((equal c '#\5) (setf expr2 '(progn (defun toto (x &optional y (z 1) &rest w &key u (v 2)) (list x y z w u v))
							    (list (toto 1)
								  (toto 1 2)
								  (toto 1 2 3)
								  (toto 1 2 3 :u 4)
								  (toto 1 2 3 :v 5)
								  (toto 1 2 3 :v 5)
								  (toto 1 2 3 :u 4 :v 5)))))
			((equal c '#\6) (setf expr2 '(fibo 5)))
			((equal c '#\7) (setf expr2 '(fiboterm 5)))
			((equal c '#\8) (setf expr2 '(progn (defmacro monfuncall (fct &rest args) `(,fct ,@args))
							    (list (macroexpand '(monfuncall list (+ 1 2) (- 3 4) (* 5 6) (/ 7 8)))
								  (monfuncall list (+ 1 2) (- 3 4) (* 5 6) (/ 7 8))))))
			((equal c '#\9) (setf expr2 '(fact 30)))
			((equal c '#\0) (setf expr2 '(factterm 30)))
			((and (not (equal c '#\r)) (not (equal c '#\R))) (setf nod t)))
		  (if (not (null expr2)) (progn (setf expr2 (aux n expr2))
						(pgdwn)
						(setf expr (eval (list 'time expr2))))))
		(pgdwn)))
	     ((equal c '#\2) 
	      (pgdwn)
	      (let (c)
		(setf n 0)
		(debogage-desactive)
		(loop while (and (not (equal c '#\r)) (not (equal c '#\R))) do
		  (if (not nod)
		      (progn (format *standard-output* "~%**********************************************************************************************~%")
			     (format *standard-output* "   1> Compiler le métaévaluateur~%")
			     (format *standard-output* "2) 2> Compiler le générateur de code~%")
			     (format *standard-output* "   3> Compiler les utilitaires d'automates~%")
			     (format *standard-output* "   4> Compiler la fonction récursive fibo~%")
			     (format *standard-output* "   5> Compiler la fonction récursive terminale fiboterm~%")
			     (format *standard-output* "   6> Compiler la fonction récursive enveloppée fact~%")			     
			     (format *standard-output* "   7> Compiler la fonction récursive terminale factterm~%")
			     (format *standard-output* "   +) Ajouter un niveau de métaévaluation~%")
			     (format *standard-output* "   -) Retirer un niveau de métaévaluation~%")
			     (format *standard-output* "   U> Générer du code pour une expression~%")
			     (format *standard-output* "   V> Compiler une fonction ou macro~%")
			     (format *standard-output* "   D) Activer / désactiver le débuggage de la machine virtuelle~%")
			     (format *standard-output* "   R) Retour~%")
			     (state)
			     (format *standard-output* "Faites votre choix: "))
		    (setf nod nil))
		  (clear-input)
		  (setf c (read-char))
		  (setf expr2 ())
		  (cond ((equal c '#\+) (meval+) (pgdwn))
			((equal c '#\-) (meval-) (pgdwn))
			((or (equal c '#\d) (equal c '#\D)) (debogage-inverse) (pgdwn))
			((equal c '#\1) (setf expr2 '(vm-compile-function-list lstfctmeval)))
			((equal c '#\2) (setf expr2 '(vm-compile-function-list lstfctcomp)))
			((equal c '#\3) (setf expr2 '(vm-compile-function-list lstfctauto)))
			((equal c '#\4) (setf expr2 '(progn (vm-compile-function 'fibo) (fcorps (fctvaleur 'fibo ensvar ensfct)))))
			((equal c '#\5) (setf expr2 '(progn (vm-compile-function 'fiboterm) (fcorps (fctvaleur 'fiboterm ensvar ensfct)))))
			((equal c '#\6) (setf expr2 '(progn (vm-compile-function 'fact) (fcorps (fctvaleur 'fact ensvar ensfct)))))
			((equal c '#\7) (setf expr2 '(progn (vm-compile-function 'factterm) (fcorps (fctvaleur 'factterm ensvar ensfct)))))
			((or (equal c '#\V) (equal c '#\v)) (let ((r (read)))
							      (if (not (symbolp r))
								  (while loop (not (symbolp r)) do
									 (format *standard-output* "Entrez un nom de fonction ou macro: ")
									 (setf r (read))))
							      (setf expr2 `(progn (vm-compile-function ,(list 'quote r)) (fcorps (fctvaleur ,(list 'quote r) ensvar ensfct))))))
			((or (equal c '#\U) (equal c '#\u)) (setf expr2 (list 'vm-compile (list 'quote (read)))))
			((or (equal c '#\t) (equal c '#\T)) (chgtime))
			((or (equal c '#\c) (equal c '#\C)) (let ((r (read)))
							      (if (not (symbolp r))
								  (while loop (not (symbolp r)) do
									 (format *standard-output* "Entrez un nom de fonction ou macro: ")
									 (setf r (read))))
							      (setf expr2 `(fcorps (fctvaleur ,(list 'quote r) ensvar ensfct)))))
			((and (not (equal c '#\r)) (not (equal c '#\R))) (setf nod t)))
		  (if (not (null expr2)) (progn (setf expr2 (aux n expr2))
						(pgdwn)
						(setf expr (eval (list 'time expr2))))))
		(pgdwn)))
	     ((equal c '#\3) 
	      (pgdwn)
	      (let (c)
		(setf n 0)
		(debogage-active)
		(loop while (and (not (equal c '#\r)) (not (equal c '#\R))) do
		  (if (not nod)
		      (progn (format *standard-output* "~%**********************************************************************************************~%")
			     (format *standard-output* "   1> Fibo récursive enveloppée~%")
			     (format *standard-output* "   2> Code auto-modifiant~%")
			     (format *standard-output* "3) 3> Point d'arret conditionnel~%")
			     (format *standard-output* "   +) Ajouter un niveau de métaévaluation~%")
			     (format *standard-output* "   -) Retirer un niveau de métaévaluation~%")
			     (format *standard-output* "   D) Activer / désactiver le débuggage de la machine virtuelle~%")
			     (format *standard-output* "   V> Evaluer du code dans la machine virtuelle~%")
			     (format *standard-output* "   U> Evaluer dans la machine virtuelle le code généré pour une expression~%")
			     (format *standard-output* "   S> Evaluer le résultat dans la machine virtuelle~%")
			     (format *standard-output* "   R) Retour~%")
			     (state)
			     (format *standard-output* "Faites votre choix: "))
		    (setf nod nil))
		  (clear-input)
		  (setf c (read-char))
		  (setf expr2 ())
		  (cond
		   ((equal c '#\+) (meval+) (pgdwn))
		   ((equal c '#\-) (meval-) (pgdwn))
		   ((or (equal c '#\d) (equal c '#\D)) (debogage-inverse) (pgdwn))
		   ((or (equal c '#\U) (equal c '#\u)) (setf expr2 `(lance-code-appel ',(vm-compile (read)))))
		   ((or (equal c '#\V) (equal c '#\v)) (setf expr2 (list 'lance-code-appel (list 'quote (read)))))
		   ((or (equal c '#\S) (equal c '#\s)) (setf expr2 (list 'lance-code-appel (list 'quote expr))))
		   ((equal c '#\1) (setf expr2 `(vm-apply 'fibo '(12))))
		   ((equal c '#\2) (setf expr2 (list 'lance-code-appel ''((MOVEI A0 10)
									 (MOVEI A1 (movei A1 100))
									 (POKE  4 A1)
									 (movei A5 4567)
									 (end)))))
		   ((equal c '#\3) (setf expr2 (list 'lance-code-appel ''((movei A1 7)
									 (movei A0 1)
									 boucle
									 (ADD A0 1)
									 (SUB A1 1)
									 (ENDC A0 A1)
									 (JEQ A0 A1 FIN)
									 (JMP BOUCLE)
									 FIN
									 (PUSH A0)
									 (POP A0)
									 (END)))))
		   ((and (not (equal c '#\r)) (not (equal c '#\R))) (setf nod t)))
		  (if (not (null expr2)) (progn (setf expr2 (aux n expr2))
						(pgdwn)
						(setf expr (eval (list 'time expr2))))))
		(pgdwn)))
	     ((equal c '#\4)
	      (pgdwn)
	      (let (c)
		(setf n 0)
		(debogage-desactive)
		(loop while (and (not (equal c '#\r)) (not (equal c '#\R))) do
		  (if (not nod)
		      (progn (format *standard-output* "~%**********************************************************************************************~%")
			     (format *standard-output* "   1> Définir l'automate A1~%")
			     (format *standard-output* "   2> Définir l'automate A1 par son expression régulière~%")
			     (format *standard-output* "   3> Déterminisation de A1~%")
			     (format *standard-output* "4) 4> Minimisation de A1~%")
			     (format *standard-output* "   5> Reconnaitre un mot de A1~%")
			     (format *standard-output* "   6> Compiler A1~%")
			     (format *standard-output* "   +) Ajouter un niveau de métaévaluation~%")
			     (format *standard-output* "   -) Retirer un niveau de métaévaluation~%")
			     (format *standard-output* "   D) Activer / désactiver le débuggage de la machine virtuelle~%")
			     (format *standard-output* "   R) Retour~%")
			     (stata)
			     (format *standard-output* "Faites votre choix: "))
		    (setf nod nil))
		  (clear-input)
		  (setf c (read-char))
		  (setf expr2 ())
		  (cond 
					;insérer ici les exemples
		   ((equal c '#\+) (meval+) (pgdwn))
		   ((equal c '#\-) (meval-) (pgdwn))
		   ((or (equal c '#\d) (equal c '#\D)) (debogage-inverse) (pgdwn))
		   ((equal c '#\1) (setf expr2 `(A1 (defautomate :vocabulaire ',(read) :etats ',(read) :initiaux ',(read) :finaux ',(read) :transitions ',(read)))))
		   ((equal c '#\2) (setf expr2 `(A1 (make-automate ',(read)))))
		   ((equal c '#\3) (setf expr2 `(A1 (determinise-auto ',A1))))
		   ((equal c '#\4) (setf expr2 `(A1 (minimise-auto ',A1))))
		   ((equal c '#\5) (setf expr2 `(eval-automate ',(read) ',A1)))
		   ((equal c '#\6) (setf expr2 `(compile-auto :initial ,(initial A1) :finaux ,(finaux A1) :transitions ,(transitions A1))))
		   ((and (not (equal c '#\r)) (not (equal c '#\R))) (setf nod t)))
		  (if (not (null expr2))
		      (if (equal (car expr2) 'A1)
			  (progn (pgdwn)
				 (setf expr2 (aux n (cadr expr2)))
				 (setf expr (eval (list 'time expr2)))
				 (setf A1 expr))
			(progn (pgdwn)
			       (setf expr2 (aux n expr2))
			       (setf expr (eval (list 'time expr2)))))))
		(pgdwn)))
	     (t (setf nod t))))))

()